# -*- coding: utf-8 -*-
"""porthall 전처리

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Knpj9mcCrW3pII3ilPhaD6DL4VMv0geL
"""

from google.colab import drive
drive.mount('/content/drive')  # Google Drive 마운트

# 올바른 data_dir 경로를 설정
data_dir = '/content/drive/My Drive/data_road'  # 실제 데이터셋 위치에 맞게 수정

import os

# data_road 폴더 경로 설정 (실제 경로로 변경)
data_dir = '/content/drive/My Drive/data_road'

# data_road 폴더가 존재하는지 확인
if os.path.exists(data_dir):
    print("data_road 폴더가 존재합니다.")
else:
    print("data_road 폴더를 찾을 수 없습니다.")

# training 폴더 내 구조 확인
training_dir = os.path.join(data_dir, 'training')
if os.path.exists(training_dir):
    print("training 폴더가 존재합니다.")
    print("training 폴더 내용:", os.listdir(training_dir))
else:
    print("training 폴더를 찾을 수 없습니다.")

# training/image_2 폴더 확인
image_2_dir = os.path.join(training_dir, 'image_2')
if os.path.exists(image_2_dir):
    print("image_2 폴더 내용:", os.listdir(image_2_dir))
else:
    print("image_2 폴더를 찾을 수 없습니다.")

from google.colab.patches import cv2_imshow

from google.colab import drive
drive.mount('/content/drive')  # Google Drive 마운트

import os
import cv2
import numpy as np

# data_road 폴더 경로 설정 (실제 경로로 변경)
data_dir = '/content/drive/My Drive/data_road'

def preprocess_training_images(data_dir, img_size=(256, 256)):
    """
    training 폴더의 이미지 데이터를 전처리합니다.

    Args:
        data_dir (str): 데이터 폴더 경로.
        img_size (tuple): (width, height) 크기로 이미지를 조정. 기본값은 (256, 256).

    Returns:
        tuple: 전처리된 이미지 배열과 레이블 배열.
    """
    images = []
    labels = []

    split_dir = os.path.join(data_dir, "training")
    image_dir = os.path.join(split_dir, "image_2")  # 'image_2' 디렉토리 사용

    if not os.path.exists(image_dir):
        print(f"경고: 디렉토리를 찾을 수 없습니다: {image_dir}")
        return np.array(images), np.array(labels)

    for filename in os.listdir(image_dir):
        if filename.lower().endswith((".png", ".jpg", ".jpeg")):
            img_path = os.path.join(image_dir, filename)

            try:
                img = cv2.imread(img_path)
                if img is None:
                    print(f"이미지를 읽을 수 없습니다: {img_path}")
                    continue

                # BGR 이미지를 Grayscale로 변환
                gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

                # 이미지 크기 조정
                gray_resized = cv2.resize(gray, img_size)

                # 포트홀 검출
                detected_img = detect_potholes(gray_resized)

                # 전처리된 이미지 및 레이블 추가
                images.append(detected_img)
                labels.append(1)  # training 데이터는 레이블 1로 설정

            except Exception as e:
                print(f"오류 발생 {filename}: {e}")
                raise e  # 예외 다시 발생

    return np.array(images), np.array(labels)

def detect_potholes(gray_img):
    # 가우시안 블러 처리
    blurred = cv2.GaussianBlur(gray_img, (5, 5), 0)

    # Canny Edge Detection 적용
    edges = cv2.Canny(blurred, 50, 150)

    # Hough Circle Transform을 사용하여 원 검출
    circles = cv2.HoughCircles(edges, cv2.HOUGH_GRADIENT, dp=1, minDist=20, param1=50, param2=30, minRadius=10, maxRadius=50)

    if circles is not None:
        circles = np.round(circles[0, :]).astype("int")
        for (x, y, r) in circles:
            # 원 주위에 초록색 원 그리기
            cv2.circle(gray_img, (x, y), r, (0, 255, 0), 4)

    return gray_img

# preprocess_training_images 함수를 호출하여 이미지 전처리 및 포트홀 검출 수행
images, labels = preprocess_training_images(data_dir)

# 전처리 결과 확인
print(f"전처리된 이미지 수: {len(images)}")
print(f"전처리된 레이블 수: {len(labels)}")

# 전처리된 이미지 출력
for i, image in enumerate(images):
    cv2_imshow(image)  # cv2_imshow 사용
    cv2.waitKey(0)
    cv2.destroyAllWindows()

from google.colab import drive
drive.mount('/content/drive')  # Google Drive 마운트

import os
import cv2
import numpy as np
from google.colab.patches import cv2_imshow  # cv2_imshow 임포트

# data_road 폴더 경로 설정 (실제 경로로 변경)
data_dir = '/content/drive/My Drive/data_road'

def segment_road(image):
  """
  이미지에서 도로 영역을 분할합니다.

  Args:
    image: 입력 이미지.

  Returns:
    도로 영역 마스크.
  """

  # HSV 색 공간으로 변환
  hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)

  # 도로 색상 범위 지정 (회색, 검정)
  lower_color = (0, 0, 50)
  upper_color = (180, 100, 200)

  # 색상 범위에 해당하는 픽셀 마스크 생성
  mask = cv2.inRange(hsv, lower_color, upper_color)

  # 형태학적 연산 (선택 사항)
  kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (5, 5))
  mask = cv2.morphologyEx(mask, cv2.MORPH_OPEN, kernel)

  return mask

def preprocess_training_images(data_dir, img_size=(256, 256)):
    """
    training 폴더의 이미지 데이터를 전처리합니다.

    Args:
        data_dir (str): 데이터 폴더 경로.
        img_size (tuple): (width, height) 크기로 이미지를 조정. 기본값은 (256, 256).

    Returns:
        tuple: 전처리된 이미지 배열과 레이블 배열.
    """
    images = []
    labels = []

    split_dir = os.path.join(data_dir, "training")
    image_dir = os.path.join(split_dir, "image_2")  # 'image_2' 디렉토리 사용

    if not os.path.exists(image_dir):
        print(f"경고: 디렉토리를 찾을 수 없습니다: {image_dir}")
        return np.array(images), np.array(labels)

    for filename in os.listdir(image_dir):
        if filename.lower().endswith((".png", ".jpg", ".jpeg")):
            img_path = os.path.join(image_dir, filename)

            try:
                img = cv2.imread(img_path)
                if img is None:
                    print(f"이미지를 읽을 수 없습니다: {img_path}")
                    continue

                # 이미지 높이, 너비 가져오기
                height, width = img.shape[:2]

                # 이미지 아래 절반 자르기
                cropped_img = img[height//2:height, 0:width]

                # 이미지 크기 조정
                img_resized = cv2.resize(cropped_img, img_size)

                # --- 도로 마스크 적용 ---
                road_mask = segment_road(img_resized)  # 도로 영역 분할 함수 호출
                masked_img = cv2.bitwise_and(img_resized, img_resized, mask=road_mask)  # 마스크 적용

                # 포트홀 검출
                detected_img = detect_potholes(masked_img)  # 마스크된 이미지 사용

                # 전처리된 이미지 및 레이블 추가
                images.append(detected_img)
                labels.append(1)  # training 데이터는 레이블 1로 설정

            except Exception as e:
                print(f"오류 발생 {filename}: {e}")
                raise e  # 예외 다시 발생

    return np.array(images), np.array(labels)

def detect_potholes(img):  # 그레이스케일 이미지 대신 원본 이미지를 입력으로 받음
    # 가우시안 블러 처리
    blurred = cv2.GaussianBlur(img, (5, 5), 0)

    # Canny Edge Detection 적용
    edges = cv2.Canny(blurred, 50, 150)

    # Hough Circle Transform을 사용하여 원 검출
    circles = cv2.HoughCircles(edges, cv2.HOUGH_GRADIENT, dp=1, minDist=20, param1=50, param2=30, minRadius=10, maxRadius=50)

    if circles is not None:
        circles = np.round(circles[0, :]).astype("int")
        for (x, y, r) in circles:
            # 원 주위에 초록색 원 그리기
            cv2.circle(img, (x, y), r, (0, 255, 0), 4)  # 원본 이미지에 직접 그림

    return img  # 원본 이미지 반환

# preprocess_training_images 함수를 호출하여 이미지 전처리 및 포트홀 검출 수행
images, labels = preprocess_training_images(data_dir)

# 전처리 결과 확인
print(f"전처리된 이미지 수: {len(images)}")
print(f"전처리된 레이블 수: {len(labels)}")

# 전처리된 이미지 출력
for i, image in enumerate(images):
    cv2_imshow(image)  # cv2_imshow 사용
    cv2.waitKey(0)
    cv2.destroyAllWindows()